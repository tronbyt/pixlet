
type {{ .GoName }} struct {
	{{ .GoNameWithPackage }}
{{- range .Attributes }}
{{- if or .GenerateField (eq .GoType "starlark.Value") (eq .GoType "starlark.Tuple") (eq .GoType "*starlark.List") }}
	starlark{{ .GoName }} {{ .GoType }}
{{- end }}
{{- end }}
{{- if .HasSize }}
	size *starlark.Builtin
{{- end }}
{{- if .GoWidgetName }}
	frame_count *starlark.Builtin
{{- end }}
}

func new{{ .GoName }}(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		{{ range .Attributes -}}
        {{- if not .IsReadOnly }}{{ .StarlarkName }} {{ .GoType }}{{ end }}
		{{ end }}
	)

	if err := starlark.UnpackArgs(
		"{{ .GoName }}",
		args, kwargs,
{{- range .Attributes }}
{{- if not .IsReadOnly }}
		"{{ .StarlarkName }}{{ if not .IsRequired }}?{{ end }}", &{{ .StarlarkName }},
{{- end}}
{{- end }}
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for {{ .GoName }}: %s", err)
	}

	w := &{{ .GoName }}{}

{{- range .Attributes }}
{{ .Code }}
{{- end }}

{{- if .HasSize }}
	w.size = starlark.NewBuiltin("size", {{ .GoName | ToLower }}Size)
{{- end }}
{{- if .GoWidgetName }}
	w.frame_count = starlark.NewBuiltin("frame_count", {{ .GoName | ToLower }}FrameCount)
{{- end }}

{{- if .HasInit }}
	if err := w.Init(thread); err != nil {
		return nil, err
	}
{{- end }}

	return w, nil
}

{{ if .GoRootName -}}
func (w *{{ .GoName }}) AsRenderRoot() render.Root {
	return w.{{ .GoName }}
}
{{- end }}

{{ if .GoWidgetName -}}
func (w *{{ .GoName }}) AsRenderWidget() render.Widget {
	return &w.{{ .GoName }}
}
{{- end }}

func (w *{{ .GoName }}) AttrNames() []string {
	return []string{
{{- range .Attributes }}
		"{{ .StarlarkName }}",
{{- end }}
	}
}

func (w *{{ .GoName }}) Attr(name string) (starlark.Value, error) {
	switch name {
{{- range .Attributes }}
	case "{{ .StarlarkName }}":
{{- if .GenerateField }}
		return w.starlark{{ .GoName }}, nil
{{- else if eq .GoType "starlark.String" }}
		return starlark.String(w.{{ .GoName }}), nil
{{- else if eq .GoType "starlark.Int" }}
		return starlark.MakeInt(int(w.{{ .GoName }})), nil
{{- else if eq .GoType "starlark.Bool" }}
		return starlark.Bool(w.{{ .GoName }}), nil
{{- else }}
		return w.starlark{{ .GoName }}, nil
{{- end }}
{{- end }}
{{- if .HasSize }}
	case "size":
		return w.size.BindReceiver(w), nil
{{- end }}
{{- if .GoWidgetName }}
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
{{- end }}
	default:
		return nil, nil
	}
}

func (w *{{ .GoName }}) String() string       { return "{{ .GoName }}(...)" }
func (w *{{ .GoName }}) Type() string         { return "{{ .GoName }}" }
func (w *{{ .GoName }}) Freeze()              {}
func (w *{{ .GoName }}) Truth() starlark.Bool { return true }

func (w *{{ .GoName }}) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

{{ if .HasSize -}}
func {{ .GoName | ToLower }}Size(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	w := b.Receiver().(*{{ .GoName }})
	width, height := w.Size()

	return starlark.Tuple([]starlark.Value{
		starlark.MakeInt(width),
		starlark.MakeInt(height),
	}), nil
}
{{- end }}

{{ if .GoWidgetName -}}
func {{ .GoName | ToLower }}FrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*{{ .GoName }})
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}
{{- end }}
