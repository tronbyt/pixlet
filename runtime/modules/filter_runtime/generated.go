package filter_runtime

// Code generated by runtime/gen. DO NOT EDIT.

import (
	"fmt"
	"image"
	"sync"

	"github.com/mitchellh/hashstructure/v2"
	"go.starlark.net/starlark"
	"go.starlark.net/starlarkstruct"

	"github.com/tronbyt/pixlet/render"
	"github.com/tronbyt/pixlet/render/filter"
	"github.com/tronbyt/pixlet/runtime/modules/render_runtime"
)

type Module struct {
	once   sync.Once
	module starlark.StringDict
}

var module = Module{}

func LoadModule() (starlark.StringDict, error) {
	module.once.Do(func() {
		module.module = starlark.StringDict{
			"filter": &starlarkstruct.Module{
				Name: "filter",
				Members: starlark.StringDict{
					"Blur":           starlark.NewBuiltin("Blur", newBlur),
					"Brightness":     starlark.NewBuiltin("Brightness", newBrightness),
					"Contrast":       starlark.NewBuiltin("Contrast", newContrast),
					"EdgeDetection":  starlark.NewBuiltin("EdgeDetection", newEdgeDetection),
					"Emboss":         starlark.NewBuiltin("Emboss", newEmboss),
					"FlipHorizontal": starlark.NewBuiltin("FlipHorizontal", newFlipHorizontal),
					"FlipVertical":   starlark.NewBuiltin("FlipVertical", newFlipVertical),
					"Gamma":          starlark.NewBuiltin("Gamma", newGamma),
					"Grayscale":      starlark.NewBuiltin("Grayscale", newGrayscale),
					"Hue":            starlark.NewBuiltin("Hue", newHue),
					"Invert":         starlark.NewBuiltin("Invert", newInvert),
					"Rotate":         starlark.NewBuiltin("Rotate", newRotate),
					"Saturation":     starlark.NewBuiltin("Saturation", newSaturation),
					"Sepia":          starlark.NewBuiltin("Sepia", newSepia),
					"Sharpen":        starlark.NewBuiltin("Sharpen", newSharpen),
					"Shear":          starlark.NewBuiltin("Shear", newShear),
					"Threshold":      starlark.NewBuiltin("Threshold", newThreshold),
				},
			},
		}
	})

	return module.module, nil
}

type Blur struct {
	filter.Blur
	starlarkWidget starlark.Value
	starlarkRadius starlark.Value
	frame_count    *starlark.Builtin
}

func newBlur(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child  starlark.Value
		radius starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Blur",
		args, kwargs,
		"child", &child,
		"radius", &radius,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Blur: %s", err)
	}

	w := &Blur{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkRadius = radius
	if val, ok := starlark.AsFloat(w.starlarkRadius); ok {
		w.Radius = val
	} else if w.starlarkRadius != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkRadius.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", blurFrameCount)

	return w, nil
}

func (w *Blur) AsRenderWidget() render.Widget {
	return &w.Blur
}

func (w *Blur) AttrNames() []string {
	return []string{
		"child",
		"radius",
	}
}

func (w *Blur) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "radius":
		return w.starlarkRadius, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Blur) String() string       { return "Blur(...)" }
func (w *Blur) Type() string         { return "Blur" }
func (w *Blur) Freeze()              {}
func (w *Blur) Truth() starlark.Bool { return true }

func (w *Blur) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func blurFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Blur)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Brightness struct {
	filter.Brightness
	starlarkWidget starlark.Value
	starlarkChange starlark.Value
	frame_count    *starlark.Builtin
}

func newBrightness(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child  starlark.Value
		change starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Brightness",
		args, kwargs,
		"child", &child,
		"change", &change,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Brightness: %s", err)
	}

	w := &Brightness{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkChange = change
	if val, ok := starlark.AsFloat(w.starlarkChange); ok {
		w.Change = val
	} else if w.starlarkChange != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkChange.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", brightnessFrameCount)

	return w, nil
}

func (w *Brightness) AsRenderWidget() render.Widget {
	return &w.Brightness
}

func (w *Brightness) AttrNames() []string {
	return []string{
		"child",
		"change",
	}
}

func (w *Brightness) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "change":
		return w.starlarkChange, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Brightness) String() string       { return "Brightness(...)" }
func (w *Brightness) Type() string         { return "Brightness" }
func (w *Brightness) Freeze()              {}
func (w *Brightness) Truth() starlark.Bool { return true }

func (w *Brightness) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func brightnessFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Brightness)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Contrast struct {
	filter.Contrast
	starlarkWidget starlark.Value
	starlarkFactor starlark.Value
	frame_count    *starlark.Builtin
}

func newContrast(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child  starlark.Value
		factor starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Contrast",
		args, kwargs,
		"child", &child,
		"factor", &factor,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Contrast: %s", err)
	}

	w := &Contrast{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkFactor = factor
	if val, ok := starlark.AsFloat(w.starlarkFactor); ok {
		w.Factor = val
	} else if w.starlarkFactor != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkFactor.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", contrastFrameCount)

	return w, nil
}

func (w *Contrast) AsRenderWidget() render.Widget {
	return &w.Contrast
}

func (w *Contrast) AttrNames() []string {
	return []string{
		"child",
		"factor",
	}
}

func (w *Contrast) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "factor":
		return w.starlarkFactor, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Contrast) String() string       { return "Contrast(...)" }
func (w *Contrast) Type() string         { return "Contrast" }
func (w *Contrast) Freeze()              {}
func (w *Contrast) Truth() starlark.Bool { return true }

func (w *Contrast) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func contrastFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Contrast)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type EdgeDetection struct {
	filter.EdgeDetection
	starlarkWidget starlark.Value
	starlarkRadius starlark.Value
	frame_count    *starlark.Builtin
}

func newEdgeDetection(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child  starlark.Value
		radius starlark.Value
	)

	if err := starlark.UnpackArgs(
		"EdgeDetection",
		args, kwargs,
		"child", &child,
		"radius", &radius,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for EdgeDetection: %s", err)
	}

	w := &EdgeDetection{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkRadius = radius
	if val, ok := starlark.AsFloat(w.starlarkRadius); ok {
		w.Radius = val
	} else if w.starlarkRadius != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkRadius.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", edgedetectionFrameCount)

	return w, nil
}

func (w *EdgeDetection) AsRenderWidget() render.Widget {
	return &w.EdgeDetection
}

func (w *EdgeDetection) AttrNames() []string {
	return []string{
		"child",
		"radius",
	}
}

func (w *EdgeDetection) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "radius":
		return w.starlarkRadius, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *EdgeDetection) String() string       { return "EdgeDetection(...)" }
func (w *EdgeDetection) Type() string         { return "EdgeDetection" }
func (w *EdgeDetection) Freeze()              {}
func (w *EdgeDetection) Truth() starlark.Bool { return true }

func (w *EdgeDetection) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func edgedetectionFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*EdgeDetection)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Emboss struct {
	filter.Emboss
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newEmboss(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Emboss",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Emboss: %s", err)
	}

	w := &Emboss{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", embossFrameCount)

	return w, nil
}

func (w *Emboss) AsRenderWidget() render.Widget {
	return &w.Emboss
}

func (w *Emboss) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *Emboss) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Emboss) String() string       { return "Emboss(...)" }
func (w *Emboss) Type() string         { return "Emboss" }
func (w *Emboss) Freeze()              {}
func (w *Emboss) Truth() starlark.Bool { return true }

func (w *Emboss) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func embossFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Emboss)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type FlipHorizontal struct {
	filter.FlipHorizontal
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newFlipHorizontal(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"FlipHorizontal",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for FlipHorizontal: %s", err)
	}

	w := &FlipHorizontal{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", fliphorizontalFrameCount)

	return w, nil
}

func (w *FlipHorizontal) AsRenderWidget() render.Widget {
	return &w.FlipHorizontal
}

func (w *FlipHorizontal) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *FlipHorizontal) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *FlipHorizontal) String() string       { return "FlipHorizontal(...)" }
func (w *FlipHorizontal) Type() string         { return "FlipHorizontal" }
func (w *FlipHorizontal) Freeze()              {}
func (w *FlipHorizontal) Truth() starlark.Bool { return true }

func (w *FlipHorizontal) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func fliphorizontalFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*FlipHorizontal)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type FlipVertical struct {
	filter.FlipVertical
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newFlipVertical(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"FlipVertical",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for FlipVertical: %s", err)
	}

	w := &FlipVertical{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", flipverticalFrameCount)

	return w, nil
}

func (w *FlipVertical) AsRenderWidget() render.Widget {
	return &w.FlipVertical
}

func (w *FlipVertical) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *FlipVertical) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *FlipVertical) String() string       { return "FlipVertical(...)" }
func (w *FlipVertical) Type() string         { return "FlipVertical" }
func (w *FlipVertical) Freeze()              {}
func (w *FlipVertical) Truth() starlark.Bool { return true }

func (w *FlipVertical) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func flipverticalFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*FlipVertical)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Gamma struct {
	filter.Gamma
	starlarkWidget starlark.Value
	starlarkGamma  starlark.Value
	frame_count    *starlark.Builtin
}

func newGamma(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
		gamma starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Gamma",
		args, kwargs,
		"child", &child,
		"gamma", &gamma,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Gamma: %s", err)
	}

	w := &Gamma{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkGamma = gamma
	if val, ok := starlark.AsFloat(w.starlarkGamma); ok {
		w.Gamma.Gamma = val
	} else if w.starlarkGamma != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkGamma.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", gammaFrameCount)

	return w, nil
}

func (w *Gamma) AsRenderWidget() render.Widget {
	return &w.Gamma
}

func (w *Gamma) AttrNames() []string {
	return []string{
		"child",
		"gamma",
	}
}

func (w *Gamma) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "gamma":
		return w.starlarkGamma, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Gamma) String() string       { return "Gamma(...)" }
func (w *Gamma) Type() string         { return "Gamma" }
func (w *Gamma) Freeze()              {}
func (w *Gamma) Truth() starlark.Bool { return true }

func (w *Gamma) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func gammaFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Gamma)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Grayscale struct {
	filter.Grayscale
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newGrayscale(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Grayscale",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Grayscale: %s", err)
	}

	w := &Grayscale{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", grayscaleFrameCount)

	return w, nil
}

func (w *Grayscale) AsRenderWidget() render.Widget {
	return &w.Grayscale
}

func (w *Grayscale) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *Grayscale) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Grayscale) String() string       { return "Grayscale(...)" }
func (w *Grayscale) Type() string         { return "Grayscale" }
func (w *Grayscale) Freeze()              {}
func (w *Grayscale) Truth() starlark.Bool { return true }

func (w *Grayscale) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func grayscaleFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Grayscale)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Hue struct {
	filter.Hue
	starlarkWidget starlark.Value
	starlarkChange starlark.Value
	frame_count    *starlark.Builtin
}

func newHue(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child  starlark.Value
		change starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Hue",
		args, kwargs,
		"child", &child,
		"change", &change,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Hue: %s", err)
	}

	w := &Hue{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkChange = change
	if val, ok := starlark.AsFloat(w.starlarkChange); ok {
		w.Change = val
	} else if w.starlarkChange != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkChange.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", hueFrameCount)

	return w, nil
}

func (w *Hue) AsRenderWidget() render.Widget {
	return &w.Hue
}

func (w *Hue) AttrNames() []string {
	return []string{
		"child",
		"change",
	}
}

func (w *Hue) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "change":
		return w.starlarkChange, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Hue) String() string       { return "Hue(...)" }
func (w *Hue) Type() string         { return "Hue" }
func (w *Hue) Freeze()              {}
func (w *Hue) Truth() starlark.Bool { return true }

func (w *Hue) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func hueFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Hue)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Invert struct {
	filter.Invert
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newInvert(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Invert",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Invert: %s", err)
	}

	w := &Invert{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", invertFrameCount)

	return w, nil
}

func (w *Invert) AsRenderWidget() render.Widget {
	return &w.Invert
}

func (w *Invert) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *Invert) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Invert) String() string       { return "Invert(...)" }
func (w *Invert) Type() string         { return "Invert" }
func (w *Invert) Freeze()              {}
func (w *Invert) Truth() starlark.Bool { return true }

func (w *Invert) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func invertFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Invert)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Rotate struct {
	filter.Rotate
	starlarkWidget starlark.Value
	starlarkAngle  starlark.Value
	frame_count    *starlark.Builtin
}

func newRotate(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
		angle starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Rotate",
		args, kwargs,
		"child", &child,
		"angle", &angle,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Rotate: %s", err)
	}

	w := &Rotate{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkAngle = angle
	if val, ok := starlark.AsFloat(w.starlarkAngle); ok {
		w.Angle = val
	} else if w.starlarkAngle != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkAngle.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", rotateFrameCount)

	return w, nil
}

func (w *Rotate) AsRenderWidget() render.Widget {
	return &w.Rotate
}

func (w *Rotate) AttrNames() []string {
	return []string{
		"child",
		"angle",
	}
}

func (w *Rotate) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "angle":
		return w.starlarkAngle, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Rotate) String() string       { return "Rotate(...)" }
func (w *Rotate) Type() string         { return "Rotate" }
func (w *Rotate) Freeze()              {}
func (w *Rotate) Truth() starlark.Bool { return true }

func (w *Rotate) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func rotateFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Rotate)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Saturation struct {
	filter.Saturation
	starlarkWidget starlark.Value
	starlarkFactor starlark.Value
	frame_count    *starlark.Builtin
}

func newSaturation(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child  starlark.Value
		factor starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Saturation",
		args, kwargs,
		"child", &child,
		"factor", &factor,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Saturation: %s", err)
	}

	w := &Saturation{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkFactor = factor
	if val, ok := starlark.AsFloat(w.starlarkFactor); ok {
		w.Factor = val
	} else if w.starlarkFactor != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkFactor.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", saturationFrameCount)

	return w, nil
}

func (w *Saturation) AsRenderWidget() render.Widget {
	return &w.Saturation
}

func (w *Saturation) AttrNames() []string {
	return []string{
		"child",
		"factor",
	}
}

func (w *Saturation) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "factor":
		return w.starlarkFactor, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Saturation) String() string       { return "Saturation(...)" }
func (w *Saturation) Type() string         { return "Saturation" }
func (w *Saturation) Freeze()              {}
func (w *Saturation) Truth() starlark.Bool { return true }

func (w *Saturation) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func saturationFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Saturation)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Sepia struct {
	filter.Sepia
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newSepia(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Sepia",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Sepia: %s", err)
	}

	w := &Sepia{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", sepiaFrameCount)

	return w, nil
}

func (w *Sepia) AsRenderWidget() render.Widget {
	return &w.Sepia
}

func (w *Sepia) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *Sepia) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Sepia) String() string       { return "Sepia(...)" }
func (w *Sepia) Type() string         { return "Sepia" }
func (w *Sepia) Freeze()              {}
func (w *Sepia) Truth() starlark.Bool { return true }

func (w *Sepia) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func sepiaFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Sepia)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Sharpen struct {
	filter.Sharpen
	starlarkWidget starlark.Value
	frame_count    *starlark.Builtin
}

func newSharpen(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Sharpen",
		args, kwargs,
		"child", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Sharpen: %s", err)
	}

	w := &Sharpen{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", sharpenFrameCount)

	return w, nil
}

func (w *Sharpen) AsRenderWidget() render.Widget {
	return &w.Sharpen
}

func (w *Sharpen) AttrNames() []string {
	return []string{
		"child",
	}
}

func (w *Sharpen) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Sharpen) String() string       { return "Sharpen(...)" }
func (w *Sharpen) Type() string         { return "Sharpen" }
func (w *Sharpen) Freeze()              {}
func (w *Sharpen) Truth() starlark.Bool { return true }

func (w *Sharpen) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func sharpenFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Sharpen)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Shear struct {
	filter.Shear
	starlarkWidget starlark.Value
	starlarkXAngle starlark.Value
	starlarkYAngle starlark.Value
	frame_count    *starlark.Builtin
}

func newShear(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child   starlark.Value
		x_angle starlark.Value
		y_angle starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Shear",
		args, kwargs,
		"child", &child,
		"x_angle?", &x_angle,
		"y_angle?", &y_angle,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Shear: %s", err)
	}

	w := &Shear{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkXAngle = x_angle
	if val, ok := starlark.AsFloat(w.starlarkXAngle); ok {
		w.XAngle = val
	} else if w.starlarkXAngle != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkXAngle.String())
	}

	w.starlarkYAngle = y_angle
	if val, ok := starlark.AsFloat(w.starlarkYAngle); ok {
		w.YAngle = val
	} else if w.starlarkYAngle != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkYAngle.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", shearFrameCount)

	return w, nil
}

func (w *Shear) AsRenderWidget() render.Widget {
	return &w.Shear
}

func (w *Shear) AttrNames() []string {
	return []string{
		"child",
		"x_angle",
		"y_angle",
	}
}

func (w *Shear) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "x_angle":
		return w.starlarkXAngle, nil
	case "y_angle":
		return w.starlarkYAngle, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Shear) String() string       { return "Shear(...)" }
func (w *Shear) Type() string         { return "Shear" }
func (w *Shear) Freeze()              {}
func (w *Shear) Truth() starlark.Bool { return true }

func (w *Shear) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func shearFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Shear)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Threshold struct {
	filter.Threshold
	starlarkWidget starlark.Value
	starlarkLevel  starlark.Value
	frame_count    *starlark.Builtin
}

func newThreshold(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child starlark.Value
		level starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Threshold",
		args, kwargs,
		"child", &child,
		"level", &level,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Threshold: %s", err)
	}

	w := &Threshold{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Widget = childWidget.AsRenderWidget()
		w.starlarkWidget = child
	}

	w.starlarkLevel = level
	if val, ok := starlark.AsFloat(w.starlarkLevel); ok {
		w.Level = val
	} else if w.starlarkLevel != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkLevel.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", thresholdFrameCount)

	return w, nil
}

func (w *Threshold) AsRenderWidget() render.Widget {
	return &w.Threshold
}

func (w *Threshold) AttrNames() []string {
	return []string{
		"child",
		"level",
	}
}

func (w *Threshold) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkWidget, nil
	case "level":
		return w.starlarkLevel, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Threshold) String() string       { return "Threshold(...)" }
func (w *Threshold) Type() string         { return "Threshold" }
func (w *Threshold) Freeze()              {}
func (w *Threshold) Truth() starlark.Bool { return true }

func (w *Threshold) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func thresholdFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Threshold)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}
