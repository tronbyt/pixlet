// Code generated by runtime/gen. DO NOT EDIT.

package render_runtime

import (
	"fmt"
	"image"
	"sync"

	"github.com/mitchellh/hashstructure/v2"
	"go.starlark.net/starlark"
	"go.starlark.net/starlarkstruct"

	"github.com/tronbyt/pixlet/render"
	"github.com/tronbyt/pixlet/starlarkutil"
	"github.com/tronbyt/pixlet/tools/iterutil"
)

type RenderModule struct {
	once   sync.Once
	module starlark.StringDict
}

var renderModule = RenderModule{}

func LoadRenderModule() (starlark.StringDict, error) {
	var err error

	renderModule.once.Do(func() {
		var fontList []string
		if fontList, err = render.GetFontList(); err != nil {
			return
		}
		fnt := starlark.NewDict(len(fontList))
		for _, name := range fontList {
			fnt.SetKey(starlark.String(name), starlark.String(name))
		}
		fnt.Freeze()

		renderModule.module = starlark.StringDict{
			"render": &starlarkstruct.Module{
				Name: "render",
				Members: starlark.StringDict{
					"fonts":       fnt,
					"Animation":   starlark.NewBuiltin("Animation", newAnimation),
					"Arc":         starlark.NewBuiltin("Arc", newArc),
					"Box":         starlark.NewBuiltin("Box", newBox),
					"Circle":      starlark.NewBuiltin("Circle", newCircle),
					"Column":      starlark.NewBuiltin("Column", newColumn),
					"Emoji":       starlark.NewBuiltin("Emoji", newEmoji),
					"Image":       starlark.NewBuiltin("Image", newImage),
					"Line":        starlark.NewBuiltin("Line", newLine),
					"Marquee":     starlark.NewBuiltin("Marquee", newMarquee),
					"Padding":     starlark.NewBuiltin("Padding", newPadding),
					"PieChart":    starlark.NewBuiltin("PieChart", newPieChart),
					"Plot":        starlark.NewBuiltin("Plot", newPlot),
					"Polygon":     starlark.NewBuiltin("Polygon", newPolygon),
					"Root":        starlark.NewBuiltin("Root", newRoot),
					"Row":         starlark.NewBuiltin("Row", newRow),
					"Sequence":    starlark.NewBuiltin("Sequence", newSequence),
					"Stack":       starlark.NewBuiltin("Stack", newStack),
					"Text":        starlark.NewBuiltin("Text", newText),
					"WrappedText": starlark.NewBuiltin("WrappedText", newWrappedText),
				},
			},
			"canvas": &starlarkstruct.Module{
				Name: "canvas",
				Members: starlark.StringDict{
					"width":  starlark.NewBuiltin("width", dimension(dimensionWidth)),
					"height": starlark.NewBuiltin("height", dimension(dimensionHeight)),
					"size":   starlark.NewBuiltin("size", size),
					"is2x":   starlark.NewBuiltin("is2x", is2x),
				},
			},
		}
	})

	return renderModule.module, err
}

type Rootable interface {
	AsRenderRoot() render.Root
}

type Widget interface {
	AsRenderWidget() render.Widget
}

type Animation struct {
	render.Animation
	starlarkChildren *starlark.List
	frame_count      *starlark.Builtin
}

func newAnimation(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		children *starlark.List
	)

	if err := starlark.UnpackArgs(
		"Animation",
		args, kwargs,
		"children?", &children,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Animation: %s", err)
	}

	w := &Animation{}

	for i, childrenVal := range iterutil.Enumerate(children.Elements()) {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(), i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.frame_count = starlark.NewBuiltin("frame_count", animationFrameCount)

	return w, nil
}

func (w *Animation) AsRenderWidget() render.Widget {
	return &w.Animation
}

func (w *Animation) AttrNames() []string {
	return []string{
		"children",
	}
}

func (w *Animation) Attr(name string) (starlark.Value, error) {
	switch name {
	case "children":
		return w.starlarkChildren, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Animation) String() string       { return "Animation(...)" }
func (w *Animation) Type() string         { return "Animation" }
func (w *Animation) Freeze()              {}
func (w *Animation) Truth() starlark.Bool { return true }

func (w *Animation) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func animationFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Animation)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Arc struct {
	render.Arc
	starlarkX          starlark.Value
	starlarkY          starlark.Value
	starlarkRadius     starlark.Value
	starlarkStartAngle starlark.Value
	starlarkEndAngle   starlark.Value
	starlarkColor      starlark.String
	starlarkWidth      starlark.Value
	frame_count        *starlark.Builtin
}

func newArc(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		x           starlark.Value
		y           starlark.Value
		radius      starlark.Value
		start_angle starlark.Value
		end_angle   starlark.Value
		color       starlark.String
		width       starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Arc",
		args, kwargs,
		"x", &x,
		"y", &y,
		"radius", &radius,
		"start_angle", &start_angle,
		"end_angle", &end_angle,
		"color", &color,
		"width", &width,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Arc: %s", err)
	}

	w := &Arc{}

	w.starlarkX = x
	if val, ok := starlark.AsFloat(w.starlarkX); ok {
		w.X = val
	} else if w.starlarkX != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkX.String())
	}

	w.starlarkY = y
	if val, ok := starlark.AsFloat(w.starlarkY); ok {
		w.Y = val
	} else if w.starlarkY != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkY.String())
	}

	w.starlarkRadius = radius
	if val, ok := starlark.AsFloat(w.starlarkRadius); ok {
		w.Radius = val
	} else if w.starlarkRadius != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkRadius.String())
	}

	w.starlarkStartAngle = start_angle
	if val, ok := starlark.AsFloat(w.starlarkStartAngle); ok {
		w.StartAngle = val
	} else if w.starlarkStartAngle != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkStartAngle.String())
	}

	w.starlarkEndAngle = end_angle
	if val, ok := starlark.AsFloat(w.starlarkEndAngle); ok {
		w.EndAngle = val
	} else if w.starlarkEndAngle != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkEndAngle.String())
	}

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.starlarkWidth = width
	if val, ok := starlark.AsFloat(w.starlarkWidth); ok {
		w.Width = val
	} else if w.starlarkWidth != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkWidth.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", arcFrameCount)

	return w, nil
}

func (w *Arc) AsRenderWidget() render.Widget {
	return &w.Arc
}

func (w *Arc) AttrNames() []string {
	return []string{
		"x",
		"y",
		"radius",
		"start_angle",
		"end_angle",
		"color",
		"width",
	}
}

func (w *Arc) Attr(name string) (starlark.Value, error) {
	switch name {
	case "x":
		return w.starlarkX, nil
	case "y":
		return w.starlarkY, nil
	case "radius":
		return w.starlarkRadius, nil
	case "start_angle":
		return w.starlarkStartAngle, nil
	case "end_angle":
		return w.starlarkEndAngle, nil
	case "color":
		return w.starlarkColor, nil
	case "width":
		return w.starlarkWidth, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Arc) String() string       { return "Arc(...)" }
func (w *Arc) Type() string         { return "Arc" }
func (w *Arc) Freeze()              {}
func (w *Arc) Truth() starlark.Bool { return true }

func (w *Arc) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func arcFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Arc)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Box struct {
	render.Box
	starlarkChild starlark.Value
	starlarkColor starlark.String
	frame_count   *starlark.Builtin
}

func newBox(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child   starlark.Value
		width   starlark.Int
		height  starlark.Int
		padding starlark.Int
		color   starlark.String
	)

	if err := starlark.UnpackArgs(
		"Box",
		args, kwargs,
		"child?", &child,
		"width?", &width,
		"height?", &height,
		"padding?", &padding,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Box: %s", err)
	}

	w := &Box{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	widthInt, err := starlarkutil.AsInt64(width)
	if err != nil {
		return nil, fmt.Errorf("parsing width: %w", err)
	}
	w.Width = int(widthInt)

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	paddingInt, err := starlarkutil.AsInt64(padding)
	if err != nil {
		return nil, fmt.Errorf("parsing padding: %w", err)
	}
	w.Padding = int(paddingInt)

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.frame_count = starlark.NewBuiltin("frame_count", boxFrameCount)

	return w, nil
}

func (w *Box) AsRenderWidget() render.Widget {
	return &w.Box
}

func (w *Box) AttrNames() []string {
	return []string{
		"child",
		"width",
		"height",
		"padding",
		"color",
	}
}

func (w *Box) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkChild, nil
	case "width":
		return starlark.MakeInt(int(w.Width)), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "padding":
		return starlark.MakeInt(int(w.Padding)), nil
	case "color":
		return w.starlarkColor, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Box) String() string       { return "Box(...)" }
func (w *Box) Type() string         { return "Box" }
func (w *Box) Freeze()              {}
func (w *Box) Truth() starlark.Bool { return true }

func (w *Box) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func boxFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Box)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Circle struct {
	render.Circle
	starlarkColor starlark.String
	starlarkChild starlark.Value
	frame_count   *starlark.Builtin
}

func newCircle(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		color    starlark.String
		diameter starlark.Int
		child    starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Circle",
		args, kwargs,
		"color", &color,
		"diameter", &diameter,
		"child?", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Circle: %s", err)
	}

	w := &Circle{}

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	diameterInt, err := starlarkutil.AsInt64(diameter)
	if err != nil {
		return nil, fmt.Errorf("parsing diameter: %w", err)
	}
	w.Diameter = int(diameterInt)

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.frame_count = starlark.NewBuiltin("frame_count", circleFrameCount)

	return w, nil
}

func (w *Circle) AsRenderWidget() render.Widget {
	return &w.Circle
}

func (w *Circle) AttrNames() []string {
	return []string{
		"color",
		"diameter",
		"child",
	}
}

func (w *Circle) Attr(name string) (starlark.Value, error) {
	switch name {
	case "color":
		return w.starlarkColor, nil
	case "diameter":
		return starlark.MakeInt(int(w.Diameter)), nil
	case "child":
		return w.starlarkChild, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Circle) String() string       { return "Circle(...)" }
func (w *Circle) Type() string         { return "Circle" }
func (w *Circle) Freeze()              {}
func (w *Circle) Truth() starlark.Bool { return true }

func (w *Circle) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func circleFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Circle)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Column struct {
	render.Column
	starlarkChildren *starlark.List
	frame_count      *starlark.Builtin
}

func newColumn(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		children    *starlark.List
		main_align  starlark.String
		cross_align starlark.String
		expanded    starlark.Bool
	)

	if err := starlark.UnpackArgs(
		"Column",
		args, kwargs,
		"children", &children,
		"main_align?", &main_align,
		"cross_align?", &cross_align,
		"expanded?", &expanded,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Column: %s", err)
	}

	w := &Column{}

	for i, childrenVal := range iterutil.Enumerate(children.Elements()) {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(), i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.MainAlign = main_align.GoString()

	w.CrossAlign = cross_align.GoString()

	w.Expanded = bool(expanded)

	w.frame_count = starlark.NewBuiltin("frame_count", columnFrameCount)

	return w, nil
}

func (w *Column) AsRenderWidget() render.Widget {
	return &w.Column
}

func (w *Column) AttrNames() []string {
	return []string{
		"children",
		"main_align",
		"cross_align",
		"expanded",
	}
}

func (w *Column) Attr(name string) (starlark.Value, error) {
	switch name {
	case "children":
		return w.starlarkChildren, nil
	case "main_align":
		return starlark.String(w.MainAlign), nil
	case "cross_align":
		return starlark.String(w.CrossAlign), nil
	case "expanded":
		return starlark.Bool(w.Expanded), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Column) String() string       { return "Column(...)" }
func (w *Column) Type() string         { return "Column" }
func (w *Column) Freeze()              {}
func (w *Column) Truth() starlark.Bool { return true }

func (w *Column) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func columnFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Column)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Emoji struct {
	render.Emoji
	size        *starlark.Builtin
	frame_count *starlark.Builtin
}

func newEmoji(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		emoji  starlark.String
		width  starlark.Int
		height starlark.Int
	)

	if err := starlark.UnpackArgs(
		"Emoji",
		args, kwargs,
		"emoji", &emoji,
		"width?", &width,
		"height?", &height,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Emoji: %s", err)
	}

	w := &Emoji{}

	w.EmojiStr = emoji.GoString()

	widthInt, err := starlarkutil.AsInt64(width)
	if err != nil {
		return nil, fmt.Errorf("parsing width: %w", err)
	}
	w.Width = int(widthInt)

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	w.size = starlark.NewBuiltin("size", emojiSize)
	w.frame_count = starlark.NewBuiltin("frame_count", emojiFrameCount)
	if err := w.Init(thread); err != nil {
		return nil, err
	}

	return w, nil
}

func (w *Emoji) AsRenderWidget() render.Widget {
	return &w.Emoji
}

func (w *Emoji) AttrNames() []string {
	return []string{
		"emoji",
		"width",
		"height",
	}
}

func (w *Emoji) Attr(name string) (starlark.Value, error) {
	switch name {
	case "emoji":
		return starlark.String(w.EmojiStr), nil
	case "width":
		return starlark.MakeInt(int(w.Width)), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "size":
		return w.size.BindReceiver(w), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Emoji) String() string       { return "Emoji(...)" }
func (w *Emoji) Type() string         { return "Emoji" }
func (w *Emoji) Freeze()              {}
func (w *Emoji) Truth() starlark.Bool { return true }

func (w *Emoji) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func emojiSize(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	w := b.Receiver().(*Emoji)
	width, height := w.Size()

	return starlark.Tuple([]starlark.Value{
		starlark.MakeInt(width),
		starlark.MakeInt(height),
	}), nil
}

func emojiFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Emoji)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Image struct {
	render.Image
	size        *starlark.Builtin
	frame_count *starlark.Builtin
}

func newImage(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		src    starlark.String
		width  starlark.Int
		height starlark.Int

		hold_frames starlark.Int
	)

	if err := starlark.UnpackArgs(
		"Image",
		args, kwargs,
		"src", &src,
		"width?", &width,
		"height?", &height,
		"hold_frames?", &hold_frames,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Image: %s", err)
	}

	w := &Image{}

	w.Src = src.GoString()

	widthInt, err := starlarkutil.AsInt64(width)
	if err != nil {
		return nil, fmt.Errorf("parsing width: %w", err)
	}
	w.Width = int(widthInt)

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	hold_framesInt, err := starlarkutil.AsInt64(hold_frames)
	if err != nil {
		return nil, fmt.Errorf("parsing hold_frames: %w", err)
	}
	w.HoldFrames = int(hold_framesInt)

	w.size = starlark.NewBuiltin("size", imageSize)
	w.frame_count = starlark.NewBuiltin("frame_count", imageFrameCount)
	if err := w.Init(thread); err != nil {
		return nil, err
	}

	return w, nil
}

func (w *Image) AsRenderWidget() render.Widget {
	return &w.Image
}

func (w *Image) AttrNames() []string {
	return []string{
		"src",
		"width",
		"height",
		"delay",
		"hold_frames",
	}
}

func (w *Image) Attr(name string) (starlark.Value, error) {
	switch name {
	case "src":
		return starlark.String(w.Src), nil
	case "width":
		return starlark.MakeInt(int(w.Width)), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "delay":
		return starlark.MakeInt(int(w.Delay)), nil
	case "hold_frames":
		return starlark.MakeInt(int(w.HoldFrames)), nil
	case "size":
		return w.size.BindReceiver(w), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Image) String() string       { return "Image(...)" }
func (w *Image) Type() string         { return "Image" }
func (w *Image) Freeze()              {}
func (w *Image) Truth() starlark.Bool { return true }

func (w *Image) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func imageSize(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	w := b.Receiver().(*Image)
	width, height := w.Size()

	return starlark.Tuple([]starlark.Value{
		starlark.MakeInt(width),
		starlark.MakeInt(height),
	}), nil
}

func imageFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Image)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Line struct {
	render.Line
	starlarkX1    starlark.Value
	starlarkY1    starlark.Value
	starlarkX2    starlark.Value
	starlarkY2    starlark.Value
	starlarkColor starlark.String
	starlarkWidth starlark.Value
	frame_count   *starlark.Builtin
}

func newLine(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		x1    starlark.Value
		y1    starlark.Value
		x2    starlark.Value
		y2    starlark.Value
		color starlark.String
		width starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Line",
		args, kwargs,
		"x1", &x1,
		"y1", &y1,
		"x2", &x2,
		"y2", &y2,
		"color", &color,
		"width", &width,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Line: %s", err)
	}

	w := &Line{}

	w.starlarkX1 = x1
	if val, ok := starlark.AsFloat(w.starlarkX1); ok {
		w.X1 = val
	} else if w.starlarkX1 != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkX1.String())
	}

	w.starlarkY1 = y1
	if val, ok := starlark.AsFloat(w.starlarkY1); ok {
		w.Y1 = val
	} else if w.starlarkY1 != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkY1.String())
	}

	w.starlarkX2 = x2
	if val, ok := starlark.AsFloat(w.starlarkX2); ok {
		w.X2 = val
	} else if w.starlarkX2 != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkX2.String())
	}

	w.starlarkY2 = y2
	if val, ok := starlark.AsFloat(w.starlarkY2); ok {
		w.Y2 = val
	} else if w.starlarkY2 != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkY2.String())
	}

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.starlarkWidth = width
	if val, ok := starlark.AsFloat(w.starlarkWidth); ok {
		w.Width = val
	} else if w.starlarkWidth != nil {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkWidth.String())
	}

	w.frame_count = starlark.NewBuiltin("frame_count", lineFrameCount)

	return w, nil
}

func (w *Line) AsRenderWidget() render.Widget {
	return &w.Line
}

func (w *Line) AttrNames() []string {
	return []string{
		"x1",
		"y1",
		"x2",
		"y2",
		"color",
		"width",
	}
}

func (w *Line) Attr(name string) (starlark.Value, error) {
	switch name {
	case "x1":
		return w.starlarkX1, nil
	case "y1":
		return w.starlarkY1, nil
	case "x2":
		return w.starlarkX2, nil
	case "y2":
		return w.starlarkY2, nil
	case "color":
		return w.starlarkColor, nil
	case "width":
		return w.starlarkWidth, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Line) String() string       { return "Line(...)" }
func (w *Line) Type() string         { return "Line" }
func (w *Line) Freeze()              {}
func (w *Line) Truth() starlark.Bool { return true }

func (w *Line) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func lineFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Line)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Marquee struct {
	render.Marquee
	starlarkChild starlark.Value
	frame_count   *starlark.Builtin
}

func newMarquee(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child            starlark.Value
		width            starlark.Int
		height           starlark.Int
		offset_start     starlark.Int
		offset_end       starlark.Int
		scroll_direction starlark.String
		align            starlark.String
		delay            starlark.Int
	)

	if err := starlark.UnpackArgs(
		"Marquee",
		args, kwargs,
		"child", &child,
		"width?", &width,
		"height?", &height,
		"offset_start?", &offset_start,
		"offset_end?", &offset_end,
		"scroll_direction?", &scroll_direction,
		"align?", &align,
		"delay?", &delay,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Marquee: %s", err)
	}

	w := &Marquee{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	widthInt, err := starlarkutil.AsInt64(width)
	if err != nil {
		return nil, fmt.Errorf("parsing width: %w", err)
	}
	w.Width = int(widthInt)

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	offset_startInt, err := starlarkutil.AsInt64(offset_start)
	if err != nil {
		return nil, fmt.Errorf("parsing offset_start: %w", err)
	}
	w.OffsetStart = int(offset_startInt)

	offset_endInt, err := starlarkutil.AsInt64(offset_end)
	if err != nil {
		return nil, fmt.Errorf("parsing offset_end: %w", err)
	}
	w.OffsetEnd = int(offset_endInt)

	w.ScrollDirection = scroll_direction.GoString()

	w.Align = align.GoString()

	delayInt, err := starlarkutil.AsInt64(delay)
	if err != nil {
		return nil, fmt.Errorf("parsing delay: %w", err)
	}
	w.Delay = int(delayInt)

	w.frame_count = starlark.NewBuiltin("frame_count", marqueeFrameCount)

	return w, nil
}

func (w *Marquee) AsRenderWidget() render.Widget {
	return &w.Marquee
}

func (w *Marquee) AttrNames() []string {
	return []string{
		"child",
		"width",
		"height",
		"offset_start",
		"offset_end",
		"scroll_direction",
		"align",
		"delay",
	}
}

func (w *Marquee) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkChild, nil
	case "width":
		return starlark.MakeInt(int(w.Width)), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "offset_start":
		return starlark.MakeInt(int(w.OffsetStart)), nil
	case "offset_end":
		return starlark.MakeInt(int(w.OffsetEnd)), nil
	case "scroll_direction":
		return starlark.String(w.ScrollDirection), nil
	case "align":
		return starlark.String(w.Align), nil
	case "delay":
		return starlark.MakeInt(int(w.Delay)), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Marquee) String() string       { return "Marquee(...)" }
func (w *Marquee) Type() string         { return "Marquee" }
func (w *Marquee) Freeze()              {}
func (w *Marquee) Truth() starlark.Bool { return true }

func (w *Marquee) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func marqueeFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Marquee)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Padding struct {
	render.Padding
	starlarkChild starlark.Value
	starlarkPad   starlark.Value
	starlarkColor starlark.String
	frame_count   *starlark.Builtin
}

func newPadding(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child    starlark.Value
		pad      starlark.Value
		expanded starlark.Bool
		color    starlark.String
	)

	if err := starlark.UnpackArgs(
		"Padding",
		args, kwargs,
		"child", &child,
		"pad?", &pad,
		"expanded?", &expanded,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Padding: %s", err)
	}

	w := &Padding{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.starlarkPad = pad
	switch padVal := pad.(type) {
	case starlark.Int:
		padInt, err := starlarkutil.AsInt64(padVal)
		if err != nil {
			return nil, fmt.Errorf("parsing pad: %w", err)
		}
		w.Pad.Left = int(padInt)
		w.Pad.Top = int(padInt)
		w.Pad.Right = int(padInt)
		w.Pad.Bottom = int(padInt)
	case starlark.Tuple:
		padList := []starlark.Value(padVal)
		if len(padList) != 4 {
			return nil, fmt.Errorf(
				"pad tuple must hold 4 elements (left, top, right, bottom), found %d",
				len(padList),
			)
		}
		padListInt := make([]int, 4)
		for i := range 4 {
			pi, ok := padList[i].(starlark.Int)
			if !ok {
				return nil, fmt.Errorf("pad element %d is not int", i)
			}
			padInt, err := starlarkutil.AsInt64(pi)
			if err != nil {
				return nil, fmt.Errorf("parsing pad element %d: %w", i, err)
			}
			padListInt[i] = int(padInt)
		}
		w.Pad.Left = padListInt[0]
		w.Pad.Top = padListInt[1]
		w.Pad.Right = padListInt[2]
		w.Pad.Bottom = padListInt[3]
	default:
		return nil, fmt.Errorf("pad must be int or 4-tuple of int")
	}

	w.Expanded = bool(expanded)

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.frame_count = starlark.NewBuiltin("frame_count", paddingFrameCount)

	return w, nil
}

func (w *Padding) AsRenderWidget() render.Widget {
	return &w.Padding
}

func (w *Padding) AttrNames() []string {
	return []string{
		"child",
		"pad",
		"expanded",
		"color",
	}
}

func (w *Padding) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkChild, nil
	case "pad":
		return w.starlarkPad, nil
	case "expanded":
		return starlark.Bool(w.Expanded), nil
	case "color":
		return w.starlarkColor, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Padding) String() string       { return "Padding(...)" }
func (w *Padding) Type() string         { return "Padding" }
func (w *Padding) Freeze()              {}
func (w *Padding) Truth() starlark.Bool { return true }

func (w *Padding) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func paddingFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Padding)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type PieChart struct {
	render.PieChart
	starlarkColors  *starlark.List
	starlarkWeights *starlark.List
	frame_count     *starlark.Builtin
}

func newPieChart(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		colors   *starlark.List
		weights  *starlark.List
		diameter starlark.Int
	)

	if err := starlark.UnpackArgs(
		"PieChart",
		args, kwargs,
		"colors", &colors,
		"weights", &weights,
		"diameter", &diameter,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for PieChart: %s", err)
	}

	w := &PieChart{}

	w.starlarkColors = colors
	if val, err := ColorSeriesFromStarlark(colors); err == nil {
		w.Colors = val
	} else {
		return nil, err
	}

	w.starlarkWeights = weights
	if val, err := WeightsFromStarlark(weights); err == nil {
		w.Weights = val
	} else {
		return nil, err
	}

	diameterInt, err := starlarkutil.AsInt64(diameter)
	if err != nil {
		return nil, fmt.Errorf("parsing diameter: %w", err)
	}
	w.Diameter = int(diameterInt)

	w.frame_count = starlark.NewBuiltin("frame_count", piechartFrameCount)

	return w, nil
}

func (w *PieChart) AsRenderWidget() render.Widget {
	return &w.PieChart
}

func (w *PieChart) AttrNames() []string {
	return []string{
		"colors",
		"weights",
		"diameter",
	}
}

func (w *PieChart) Attr(name string) (starlark.Value, error) {
	switch name {
	case "colors":
		return w.starlarkColors, nil
	case "weights":
		return w.starlarkWeights, nil
	case "diameter":
		return starlark.MakeInt(int(w.Diameter)), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *PieChart) String() string       { return "PieChart(...)" }
func (w *PieChart) Type() string         { return "PieChart" }
func (w *PieChart) Freeze()              {}
func (w *PieChart) Truth() starlark.Bool { return true }

func (w *PieChart) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func piechartFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*PieChart)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Plot struct {
	render.Plot
	starlarkData              *starlark.List
	starlarkColor             starlark.String
	starlarkColorInverted     starlark.String
	starlarkXLim              starlark.Tuple
	starlarkYLim              starlark.Tuple
	starlarkFillColor         starlark.String
	starlarkFillColorInverted starlark.String
	frame_count               *starlark.Builtin
}

func newPlot(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		data                *starlark.List
		width               starlark.Int
		height              starlark.Int
		color               starlark.String
		color_inverted      starlark.String
		x_lim               starlark.Tuple
		y_lim               starlark.Tuple
		fill                starlark.Bool
		chart_type          starlark.String
		fill_color          starlark.String
		fill_color_inverted starlark.String
	)

	if err := starlark.UnpackArgs(
		"Plot",
		args, kwargs,
		"data", &data,
		"width", &width,
		"height", &height,
		"color?", &color,
		"color_inverted?", &color_inverted,
		"x_lim?", &x_lim,
		"y_lim?", &y_lim,
		"fill?", &fill,
		"chart_type?", &chart_type,
		"fill_color?", &fill_color,
		"fill_color_inverted?", &fill_color_inverted,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Plot: %s", err)
	}

	w := &Plot{}

	w.starlarkData = data
	if val, err := DataSeriesFromStarlark(data); err == nil {
		w.Data = val
	} else {
		return nil, err
	}

	widthInt, err := starlarkutil.AsInt64(width)
	if err != nil {
		return nil, fmt.Errorf("parsing width: %w", err)
	}
	w.Width = int(widthInt)

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.starlarkColorInverted = color_inverted
	if color_inverted.Len() > 0 {
		c, err := render.ParseColor(color_inverted.GoString())
		if err != nil {
			return nil, fmt.Errorf("color_inverted is not a valid hex string: %s", color_inverted.String())
		}
		w.ColorInverted = c
	}

	w.starlarkXLim = x_lim
	if val, err := DataPointFromStarlark(x_lim); err == nil {
		w.XLim = val
	} else {
		return nil, err
	}

	w.starlarkYLim = y_lim
	if val, err := DataPointFromStarlark(y_lim); err == nil {
		w.YLim = val
	} else {
		return nil, err
	}

	w.Fill = bool(fill)

	w.ChartType = chart_type.GoString()

	w.starlarkFillColor = fill_color
	if fill_color.Len() > 0 {
		c, err := render.ParseColor(fill_color.GoString())
		if err != nil {
			return nil, fmt.Errorf("fill_color is not a valid hex string: %s", fill_color.String())
		}
		w.FillColor = c
	}

	w.starlarkFillColorInverted = fill_color_inverted
	if fill_color_inverted.Len() > 0 {
		c, err := render.ParseColor(fill_color_inverted.GoString())
		if err != nil {
			return nil, fmt.Errorf("fill_color_inverted is not a valid hex string: %s", fill_color_inverted.String())
		}
		w.FillColorInverted = c
	}

	w.frame_count = starlark.NewBuiltin("frame_count", plotFrameCount)

	return w, nil
}

func (w *Plot) AsRenderWidget() render.Widget {
	return &w.Plot
}

func (w *Plot) AttrNames() []string {
	return []string{
		"data",
		"width",
		"height",
		"color",
		"color_inverted",
		"x_lim",
		"y_lim",
		"fill",
		"chart_type",
		"fill_color",
		"fill_color_inverted",
	}
}

func (w *Plot) Attr(name string) (starlark.Value, error) {
	switch name {
	case "data":
		return w.starlarkData, nil
	case "width":
		return starlark.MakeInt(int(w.Width)), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "color":
		return w.starlarkColor, nil
	case "color_inverted":
		return w.starlarkColorInverted, nil
	case "x_lim":
		return w.starlarkXLim, nil
	case "y_lim":
		return w.starlarkYLim, nil
	case "fill":
		return starlark.Bool(w.Fill), nil
	case "chart_type":
		return starlark.String(w.ChartType), nil
	case "fill_color":
		return w.starlarkFillColor, nil
	case "fill_color_inverted":
		return w.starlarkFillColorInverted, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Plot) String() string       { return "Plot(...)" }
func (w *Plot) Type() string         { return "Plot" }
func (w *Plot) Freeze()              {}
func (w *Plot) Truth() starlark.Bool { return true }

func (w *Plot) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func plotFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Plot)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Polygon struct {
	render.Polygon
	starlarkVertices *starlark.List
	starlarkColor    starlark.String
	frame_count      *starlark.Builtin
}

func newPolygon(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		vertices *starlark.List
		color    starlark.String
	)

	if err := starlark.UnpackArgs(
		"Polygon",
		args, kwargs,
		"vertices", &vertices,
		"color", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Polygon: %s", err)
	}

	w := &Polygon{}
	w.starlarkVertices = vertices
	if val, err := VerticesFromStarlark(vertices); err == nil {
		w.Vertices = val
	} else {
		return nil, err
	}

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.frame_count = starlark.NewBuiltin("frame_count", polygonFrameCount)

	return w, nil
}

func (w *Polygon) AsRenderWidget() render.Widget {
	return &w.Polygon
}

func (w *Polygon) AttrNames() []string {
	return []string{
		"vertices",
		"color",
	}
}

func (w *Polygon) Attr(name string) (starlark.Value, error) {
	switch name {
	case "vertices":
		return w.starlarkVertices, nil
	case "color":
		return w.starlarkColor, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Polygon) String() string       { return "Polygon(...)" }
func (w *Polygon) Type() string         { return "Polygon" }
func (w *Polygon) Freeze()              {}
func (w *Polygon) Truth() starlark.Bool { return true }

func (w *Polygon) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func polygonFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Polygon)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Root struct {
	render.Root
	starlarkChild starlark.Value
}

func newRoot(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		child               starlark.Value
		delay               starlark.Int
		max_age             starlark.Int
		show_full_animation starlark.Bool
	)

	if err := starlark.UnpackArgs(
		"Root",
		args, kwargs,
		"child", &child,
		"delay?", &delay,
		"max_age?", &max_age,
		"show_full_animation?", &show_full_animation,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Root: %s", err)
	}

	w := &Root{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	if val, err := starlark.AsInt32(delay); err == nil {
		w.Delay = int32(val)
	} else {
		return nil, err
	}

	if val, err := starlark.AsInt32(max_age); err == nil {
		w.MaxAge = int32(val)
	} else {
		return nil, err
	}

	w.ShowFullAnimation = bool(show_full_animation)

	return w, nil
}

func (w *Root) AsRenderRoot() render.Root {
	return w.Root
}

func (w *Root) AttrNames() []string {
	return []string{
		"child",
		"delay",
		"max_age",
		"show_full_animation",
	}
}

func (w *Root) Attr(name string) (starlark.Value, error) {
	switch name {
	case "child":
		return w.starlarkChild, nil
	case "delay":
		return starlark.MakeInt(int(w.Delay)), nil
	case "max_age":
		return starlark.MakeInt(int(w.MaxAge)), nil
	case "show_full_animation":
		return starlark.Bool(w.ShowFullAnimation), nil
	default:
		return nil, nil
	}
}

func (w *Root) String() string       { return "Root(...)" }
func (w *Root) Type() string         { return "Root" }
func (w *Root) Freeze()              {}
func (w *Root) Truth() starlark.Bool { return true }

func (w *Root) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Row struct {
	render.Row
	starlarkChildren *starlark.List
	frame_count      *starlark.Builtin
}

func newRow(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		children    *starlark.List
		main_align  starlark.String
		cross_align starlark.String
		expanded    starlark.Bool
	)

	if err := starlark.UnpackArgs(
		"Row",
		args, kwargs,
		"children", &children,
		"main_align?", &main_align,
		"cross_align?", &cross_align,
		"expanded?", &expanded,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Row: %s", err)
	}

	w := &Row{}

	for i, childrenVal := range iterutil.Enumerate(children.Elements()) {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(), i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.MainAlign = main_align.GoString()

	w.CrossAlign = cross_align.GoString()

	w.Expanded = bool(expanded)

	w.frame_count = starlark.NewBuiltin("frame_count", rowFrameCount)

	return w, nil
}

func (w *Row) AsRenderWidget() render.Widget {
	return &w.Row
}

func (w *Row) AttrNames() []string {
	return []string{
		"children",
		"main_align",
		"cross_align",
		"expanded",
	}
}

func (w *Row) Attr(name string) (starlark.Value, error) {
	switch name {
	case "children":
		return w.starlarkChildren, nil
	case "main_align":
		return starlark.String(w.MainAlign), nil
	case "cross_align":
		return starlark.String(w.CrossAlign), nil
	case "expanded":
		return starlark.Bool(w.Expanded), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Row) String() string       { return "Row(...)" }
func (w *Row) Type() string         { return "Row" }
func (w *Row) Freeze()              {}
func (w *Row) Truth() starlark.Bool { return true }

func (w *Row) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func rowFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Row)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Sequence struct {
	render.Sequence
	starlarkChildren *starlark.List
	frame_count      *starlark.Builtin
}

func newSequence(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		children *starlark.List
	)

	if err := starlark.UnpackArgs(
		"Sequence",
		args, kwargs,
		"children", &children,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Sequence: %s", err)
	}

	w := &Sequence{}

	for i, childrenVal := range iterutil.Enumerate(children.Elements()) {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(), i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.frame_count = starlark.NewBuiltin("frame_count", sequenceFrameCount)

	return w, nil
}

func (w *Sequence) AsRenderWidget() render.Widget {
	return &w.Sequence
}

func (w *Sequence) AttrNames() []string {
	return []string{
		"children",
	}
}

func (w *Sequence) Attr(name string) (starlark.Value, error) {
	switch name {
	case "children":
		return w.starlarkChildren, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Sequence) String() string       { return "Sequence(...)" }
func (w *Sequence) Type() string         { return "Sequence" }
func (w *Sequence) Freeze()              {}
func (w *Sequence) Truth() starlark.Bool { return true }

func (w *Sequence) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func sequenceFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Sequence)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Stack struct {
	render.Stack
	starlarkChildren *starlark.List
	frame_count      *starlark.Builtin
}

func newStack(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		children *starlark.List
	)

	if err := starlark.UnpackArgs(
		"Stack",
		args, kwargs,
		"children", &children,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Stack: %s", err)
	}

	w := &Stack{}

	for i, childrenVal := range iterutil.Enumerate(children.Elements()) {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(), i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.frame_count = starlark.NewBuiltin("frame_count", stackFrameCount)

	return w, nil
}

func (w *Stack) AsRenderWidget() render.Widget {
	return &w.Stack
}

func (w *Stack) AttrNames() []string {
	return []string{
		"children",
	}
}

func (w *Stack) Attr(name string) (starlark.Value, error) {
	switch name {
	case "children":
		return w.starlarkChildren, nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Stack) String() string       { return "Stack(...)" }
func (w *Stack) Type() string         { return "Stack" }
func (w *Stack) Freeze()              {}
func (w *Stack) Truth() starlark.Bool { return true }

func (w *Stack) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func stackFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Stack)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type Text struct {
	render.Text
	starlarkColor starlark.String
	size          *starlark.Builtin
	frame_count   *starlark.Builtin
}

func newText(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		content starlark.String
		font    starlark.String
		height  starlark.Int
		offset  starlark.Int
		color   starlark.String
	)

	if err := starlark.UnpackArgs(
		"Text",
		args, kwargs,
		"content", &content,
		"font?", &font,
		"height?", &height,
		"offset?", &offset,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Text: %s", err)
	}

	w := &Text{}

	w.Content = content.GoString()

	w.Font = font.GoString()

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	offsetInt, err := starlarkutil.AsInt64(offset)
	if err != nil {
		return nil, fmt.Errorf("parsing offset: %w", err)
	}
	w.Offset = int(offsetInt)

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.size = starlark.NewBuiltin("size", textSize)
	w.frame_count = starlark.NewBuiltin("frame_count", textFrameCount)
	if err := w.Init(thread); err != nil {
		return nil, err
	}

	return w, nil
}

func (w *Text) AsRenderWidget() render.Widget {
	return &w.Text
}

func (w *Text) AttrNames() []string {
	return []string{
		"content",
		"font",
		"height",
		"offset",
		"color",
	}
}

func (w *Text) Attr(name string) (starlark.Value, error) {
	switch name {
	case "content":
		return starlark.String(w.Content), nil
	case "font":
		return starlark.String(w.Font), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "offset":
		return starlark.MakeInt(int(w.Offset)), nil
	case "color":
		return w.starlarkColor, nil
	case "size":
		return w.size.BindReceiver(w), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *Text) String() string       { return "Text(...)" }
func (w *Text) Type() string         { return "Text" }
func (w *Text) Freeze()              {}
func (w *Text) Truth() starlark.Bool { return true }

func (w *Text) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func textSize(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	w := b.Receiver().(*Text)
	width, height := w.Size()

	return starlark.Tuple([]starlark.Value{
		starlark.MakeInt(width),
		starlark.MakeInt(height),
	}), nil
}

func textFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*Text)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}

type WrappedText struct {
	render.WrappedText
	starlarkColor starlark.String
	frame_count   *starlark.Builtin
}

func newWrappedText(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {
	var (
		content     starlark.String
		font        starlark.String
		height      starlark.Int
		width       starlark.Int
		linespacing starlark.Int
		color       starlark.String
		align       starlark.String
		wordbreak   starlark.Bool
	)

	if err := starlark.UnpackArgs(
		"WrappedText",
		args, kwargs,
		"content", &content,
		"font?", &font,
		"height?", &height,
		"width?", &width,
		"linespacing?", &linespacing,
		"color?", &color,
		"align?", &align,
		"wordbreak?", &wordbreak,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for WrappedText: %s", err)
	}

	w := &WrappedText{}

	w.Content = content.GoString()

	w.Font = font.GoString()

	heightInt, err := starlarkutil.AsInt64(height)
	if err != nil {
		return nil, fmt.Errorf("parsing height: %w", err)
	}
	w.Height = int(heightInt)

	widthInt, err := starlarkutil.AsInt64(width)
	if err != nil {
		return nil, fmt.Errorf("parsing width: %w", err)
	}
	w.Width = int(widthInt)

	linespacingInt, err := starlarkutil.AsInt64(linespacing)
	if err != nil {
		return nil, fmt.Errorf("parsing linespacing: %w", err)
	}
	w.LineSpacing = int(linespacingInt)

	w.starlarkColor = color
	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.Align = align.GoString()

	w.WordBreak = bool(wordbreak)

	w.frame_count = starlark.NewBuiltin("frame_count", wrappedtextFrameCount)
	if err := w.Init(thread); err != nil {
		return nil, err
	}

	return w, nil
}

func (w *WrappedText) AsRenderWidget() render.Widget {
	return &w.WrappedText
}

func (w *WrappedText) AttrNames() []string {
	return []string{
		"content",
		"font",
		"height",
		"width",
		"linespacing",
		"color",
		"align",
		"wordbreak",
	}
}

func (w *WrappedText) Attr(name string) (starlark.Value, error) {
	switch name {
	case "content":
		return starlark.String(w.Content), nil
	case "font":
		return starlark.String(w.Font), nil
	case "height":
		return starlark.MakeInt(int(w.Height)), nil
	case "width":
		return starlark.MakeInt(int(w.Width)), nil
	case "linespacing":
		return starlark.MakeInt(int(w.LineSpacing)), nil
	case "color":
		return w.starlarkColor, nil
	case "align":
		return starlark.String(w.Align), nil
	case "wordbreak":
		return starlark.Bool(w.WordBreak), nil
	case "frame_count":
		return w.frame_count.BindReceiver(w), nil
	default:
		return nil, nil
	}
}

func (w *WrappedText) String() string       { return "WrappedText(...)" }
func (w *WrappedText) Type() string         { return "WrappedText" }
func (w *WrappedText) Freeze()              {}
func (w *WrappedText) Truth() starlark.Bool { return true }

func (w *WrappedText) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func wrappedtextFrameCount(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	var (
		bounds starlark.Tuple
	)

	if err := starlark.UnpackArgs(
		"frame_count",
		args, kwargs,
		"bounds?", &bounds,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for frame_count: %s", err)
	}

	r := image.Rect(0, 0, 64, 32)
	if bounds != nil && bounds.Len() == 4 {
		x0, err := starlark.AsInt32(bounds.Index(0))
		if err != nil {
			return nil, fmt.Errorf("bounds[0] is not a number: %s", err)
		}
		y0, err := starlark.AsInt32(bounds.Index(1))
		if err != nil {
			return nil, fmt.Errorf("bounds[1] is not a number: %s", err)
		}
		x1, err := starlark.AsInt32(bounds.Index(2))
		if err != nil {
			return nil, fmt.Errorf("bounds[2] is not a number: %s", err)
		}
		y1, err := starlark.AsInt32(bounds.Index(3))
		if err != nil {
			return nil, fmt.Errorf("bounds[3] is not a number: %s", err)
		}
		r = image.Rect(x0, y0, x1, y1)
	}

	w := b.Receiver().(*WrappedText)
	count := w.FrameCount(r)

	return starlark.MakeInt(count), nil
}
