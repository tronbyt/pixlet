//go:build ignore

// Emoji sprite sheet generator.
//
// Usage:
//   go run ./render/gen/emoji_pack.go
// (Normally invoked via `go generate ./render`.)
//
// Scans assets/emoji/raw for PNG files named like:
//   U+1F600.png (single codepoint) OR
//   U+1F1FA_U+1F1F8.png (multi-codepoint sequence)
// Packs all images into a uniform cell sprite sheet (10x10) and emits
// `render/emoji_assets.go` containing:
//   - compressed sprite sheet bytes
//   - a map[string]EmojiGlyph (keys are the actual Unicode sequence string)
//   - constants for cell size, columns, max sequence length
//
// Multi-codepoint sequences (e.g. flags, keycap sequences) are supported.
// ZWJ (\u200D) sequences are included only if PNG assets are present; no special
// shaping is doneâ€”longest-match logic at runtime handles them.
package main

import (
    "bytes"
    "compress/zlib"
    "fmt"
    "image"
    "image/draw"
    "image/png"
    "io/fs"
    "os"
    "path/filepath"
    "sort"
    "strconv"
    "strings"
    "time"
)

const (
    cellW         = 10 // max dimension per provided assets
    cellH         = 10
    columns       = 64 // 64 * 10 = 640px wide sheet
    headerComment = "// Code generated by emoji_pack.go; DO NOT EDIT.\n"
)

// Computed at runtime.
var (
    projectRoot string
    rawDir      string
    outFile     string
)

type glyph struct {
    Runes []rune
    Path  string
}

func main() {
    // Determine project root relative to this source file / executable path.
    // When `go run` compiles, os.Args[0] points to a temp binary; we instead
    // use the current working directory and walk up until we find go.mod.
    cwd, _ := os.Getwd()
    root := findModuleRoot(cwd)
    if root == "" { // fallback: assume two levels up from gen dir
        root = filepath.Clean(filepath.Join(cwd, "..", ".."))
    }
    projectRoot = root
    rawDir = filepath.Join(projectRoot, "assets", "emoji", "raw")
    outFile = filepath.Join(projectRoot, "render", "emoji_assets.go")

    glyphs, maxSeq, err := collect()
    if err != nil {
        panic(err)
    }
    if len(glyphs) == 0 {
        fmt.Println("No emoji assets found; not writing sheet.")
        return
    }
    sheet, index := buildSheet(glyphs)
    var pngBuf bytes.Buffer
    if err := png.Encode(&pngBuf, sheet); err != nil {
        panic(err)
    }
    // zlib compress the PNG to squeeze a few KB (PNG already compressed, so modest gains).
    var zBuf bytes.Buffer
    zw := zlib.NewWriter(&zBuf)
    _, _ = zw.Write(pngBuf.Bytes())
    zw.Close()

    if err := writeOutput(pngBuf.Bytes(), zBuf.Bytes(), index, len(glyphs), maxSeq); err != nil {
        panic(err)
    }
    fmt.Printf("Generated %s with %d emoji (max sequence len %d). PNG=%d bytes zlib=%d bytes\n", outFile, len(glyphs), maxSeq, pngBuf.Len(), zBuf.Len())
}

// collect scans rawDir for U+....png names.
func collect() ([]glyph, int, error) {
    out := []glyph{}
    maxSeq := 1
    err := filepath.WalkDir(rawDir, func(path string, d fs.DirEntry, err error) error {
        if err != nil {
            return err
        }
        if d.IsDir() {
            return nil
        }
        base := filepath.Base(path)
        if !strings.HasPrefix(base, "U+") || !strings.HasSuffix(strings.ToLower(base), ".png") {
            return nil
        }
        name := strings.TrimSuffix(base, ".png")
        parts := strings.Split(name, "_")
        runes := []rune{}
        for _, p := range parts {
            if !strings.HasPrefix(p, "U+") { // skip malformed
                return nil
            }
            hexPart := strings.TrimPrefix(p, "U+")
            v, err := strconv.ParseUint(hexPart, 16, 32)
            if err != nil {
                return nil
            }
            runes = append(runes, rune(v))
        }
        if l := len(runes); l > maxSeq { maxSeq = l }
        out = append(out, glyph{Runes: runes, Path: path})
        return nil
    })
    // Stable ordering: by sequence length (desc) then lexicographically by runes.
    sort.Slice(out, func(i,j int) bool {
        if len(out[i].Runes) != len(out[j].Runes) {
            return len(out[i].Runes) > len(out[j].Runes)
        }
        ri, rj := out[i].Runes, out[j].Runes
        for k := 0; k < len(ri) && k < len(rj); k++ {
            if ri[k] != rj[k] { return ri[k] < rj[k] }
        }
        return len(ri) < len(rj)
    })
    return out, maxSeq, err
}

// buildSheet packs glyph images into an RGBA sprite sheet, returning the sheet and a map from sequence string to (x,y).
func buildSheet(glyphs []glyph) (*image.RGBA, map[string][2]int) {
    n := len(glyphs)
    rows := (n + columns - 1) / columns
    sheet := image.NewRGBA(image.Rect(0,0, columns*cellW, rows*cellH))
    index := make(map[string][2]int, n)
    for i, g := range glyphs {
        f, err := os.Open(g.Path)
        if err != nil { panic(err) }
        img, err := png.Decode(f)
        f.Close()
        if err != nil { panic(err) }
        // Destination cell rectangle.
        x := (i % columns) * cellW
        y := (i / columns) * cellH
        cellRect := image.Rect(x, y, x+cellW, y+cellH)
        draw.Draw(sheet, cellRect, image.Transparent, image.Point{}, draw.Src)
        b := img.Bounds()
        // Top-left placement; could center if smaller than cell.
        draw.Draw(sheet, image.Rect(x, y, x+b.Dx(), y+b.Dy()), img, b.Min, draw.Over)
        seqKey := string(g.Runes)
        index[seqKey] = [2]int{ x / cellW, y / cellH }
    }
    return sheet, index
}

func writeOutput(pngData, zData []byte, index map[string][2]int, count, maxSeq int) error {
    var b bytes.Buffer
    b.WriteString(headerComment)
    b.WriteString("package render\n\n")
    b.WriteString("import (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"sync\"\n)\n\n")
    b.WriteString(fmt.Sprintf("// Packed %d emoji at %dx%d cells, columns=%d, generated %s\n", count, cellW, cellH, columns, time.Now().UTC().Format(time.RFC3339)))
    b.WriteString(fmt.Sprintf("const emojiCellW = %d\nconst emojiCellH = %d\nconst emojiSheetCols = %d\nconst emojiMaxSequence = %d\n\n", cellW, cellH, columns, maxSeq))

    // zlib bytes
    b.WriteString("var emojiSheetZ = []byte{\n")
    const perLine = 24
    for i := 0; i < len(zData); i += perLine {
        end := i + perLine
        if end > len(zData) { end = len(zData) }
        b.WriteString("\t")
        for _, bt := range zData[i:end] {
            b.WriteString(fmt.Sprintf("0x%02x,", bt))
        }
        b.WriteString("\n")
    }
    b.WriteString("}\n\n")

    b.WriteString("type EmojiGlyph struct { X, Y int }\n\n")
    b.WriteString("// emojiIndex maps a Unicode sequence (string of runes) to sprite sheet cell coordinates.\n")
    b.WriteString("var emojiIndex = map[string]EmojiGlyph{\n")
    // For deterministic output, gather keys and sort by length desc then lexicographically by bytes.
    keys := make([]string, 0, len(index))
    for k := range index { keys = append(keys, k) }
    sort.Slice(keys, func(i,j int) bool {
        if len([]rune(keys[i])) != len([]rune(keys[j])) { return len([]rune(keys[i])) > len([]rune(keys[j])) }
        return keys[i] < keys[j]
    })
    for _, k := range keys {
        xy := index[k]
        // Use %q to properly escape the string literal.
        b.WriteString(fmt.Sprintf("\t%q: {X:%d, Y:%d},\n", k, xy[0], xy[1]))
    }
    b.WriteString("}\n\n")

    b.WriteString("var (\n\temojiSheetOnce sync.Once\n\temojiSheetImg *image.RGBA\n)\n\n")
    b.WriteString("func getEmojiSheet() *image.RGBA {\n")
    b.WriteString("\temojiSheetOnce.Do(func() {\n")
    b.WriteString("\t\tr, _ := zlib.NewReader(bytes.NewReader(emojiSheetZ))\n")
    b.WriteString("\t\tdefer r.Close()\n")
    b.WriteString("\t\timg, _ := png.Decode(r)\n")
    b.WriteString("\t\tif rgba, ok := img.(*image.RGBA); ok {\n")
    b.WriteString("\t\t\temojiSheetImg = rgba\n")
    b.WriteString("\t\t} else {\n")
    b.WriteString("\t\t\trb := image.NewRGBA(img.Bounds())\n")
    b.WriteString("\t\t\tdraw.Draw(rb, rb.Bounds(), img, image.Point{}, draw.Src)\n")
    b.WriteString("\t\t\temojiSheetImg = rb\n")
    b.WriteString("\t\t}\n")
    b.WriteString("\t})\n")
    b.WriteString("\treturn emojiSheetImg\n}\n")

    return os.WriteFile(outFile, b.Bytes(), 0o644)
}

// findModuleRoot walks up directories until a go.mod is found.
func findModuleRoot(start string) string {
    dir := start
    for i := 0; i < 10; i++ { // safety limit
        if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
            return dir
        }
        parent := filepath.Clean(filepath.Join(dir, ".."))
        if parent == dir { break }
        dir = parent
    }
    return ""
}
