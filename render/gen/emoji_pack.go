//go:build ignore

// Emoji sprite sheet generator.
//
// Usage:
//
//	go run ./render/gen/emoji_pack.go
//
// (Normally invoked via `go generate ./render`.)
//
// Scans assets/emoji/raw for PNG files named like:
//
//	U+1F600.png (single codepoint) OR
//	U+1F1FA_U+1F1F8.png (multi-codepoint sequence)
//
// Packs all images into a uniform cell sprite sheet (10x10) and emits
// `fonts/emoji/sprites.go` containing:
//   - embedded sprite sheet bytes
//   - a map[string]Glyph (keys are the actual Unicode sequence string)
//   - constants for cell size, columns, max sequence length
//
// Multi-codepoint sequences (e.g. flags, keycap sequences) are supported.
// ZWJ (\u200D) sequences are included only if PNG assets are present; no special
// shaping is doneâ€”longest-match logic at runtime handles them.
package main

import (
	"bytes"
	"fmt"
	"image"
	"image/draw"
	"image/png"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

const (
	cellW         = 10 // max dimension per provided assets
	cellH         = 10
	columns       = 64 // 64 * 10 = 640px wide sheet
	headerComment = "// Code generated by emoji_pack.go; DO NOT EDIT.\n"
)

// Computed at runtime.
var (
	projectRoot string
	rawDir      string
	outFile     string
	pngFile     string
)

type glyph struct {
	Runes []rune
	Path  string
}

func main() {
	// Determine project root relative to this source file / executable path.
	// When `go run` compiles, os.Args[0] points to a temp binary; we instead
	// use the current working directory and walk up until we find go.mod.
	cwd, _ := os.Getwd()
	root := findModuleRoot(cwd)
	if root == "" { // fallback: assume two levels up from gen dir
		root = filepath.Clean(filepath.Join(cwd, "..", ".."))
	}
	projectRoot = root
	fontsDir := filepath.Join(projectRoot, "fonts")
	emojiDir := filepath.Join(fontsDir, "emoji")
	if err := os.MkdirAll(emojiDir, 0o755); err != nil {
		panic(err)
	}
	rawDir = filepath.Join(projectRoot, "assets", "emoji", "raw")
	outFile = filepath.Join(emojiDir, "sprites.go")
	pngFile = filepath.Join(emojiDir, "sprites.png")

	glyphs, maxSeq, err := collect()
	if err != nil {
		panic(err)
	}
	if len(glyphs) == 0 {
		fmt.Println("No emoji assets found; not writing sheet.")
		return
	}
	sheet, index := buildSheet(glyphs)
	var pngBuf bytes.Buffer
	if err := png.Encode(&pngBuf, sheet); err != nil {
		panic(err)
	}
	if err := os.WriteFile(pngFile, pngBuf.Bytes(), 0o644); err != nil {
		panic(err)
	}

	if err := writeOutput(filepath.Base(pngFile), index, len(glyphs), maxSeq); err != nil {
		panic(err)
	}
	fmt.Printf("Generated %s and %s with %d emoji (max sequence len %d). PNG=%d bytes\n", outFile, pngFile, len(glyphs), maxSeq, pngBuf.Len())
}

// collect scans rawDir for U+....png names.
func collect() ([]glyph, int, error) {
	out := []glyph{}
	maxSeq := 1
	err := filepath.WalkDir(rawDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		base := filepath.Base(path)
		if !strings.HasPrefix(base, "U+") || !strings.HasSuffix(strings.ToLower(base), ".png") {
			return nil
		}
		name := strings.TrimSuffix(base, ".png")
		parts := strings.Split(name, "_")
		runes := []rune{}
		for _, p := range parts {
			if !strings.HasPrefix(p, "U+") { // skip malformed
				return nil
			}
			hexPart := strings.TrimPrefix(p, "U+")
			v, err := strconv.ParseUint(hexPart, 16, 32)
			if err != nil {
				return nil
			}
			runes = append(runes, rune(v))
		}
		if l := len(runes); l > maxSeq {
			maxSeq = l
		}
		out = append(out, glyph{Runes: runes, Path: path})
		return nil
	})
	// Stable ordering: by sequence length (desc) then lexicographically by runes.
	sort.Slice(out, func(i, j int) bool {
		if len(out[i].Runes) != len(out[j].Runes) {
			return len(out[i].Runes) > len(out[j].Runes)
		}
		ri, rj := out[i].Runes, out[j].Runes
		for k := 0; k < len(ri) && k < len(rj); k++ {
			if ri[k] != rj[k] {
				return ri[k] < rj[k]
			}
		}
		return len(ri) < len(rj)
	})
	return out, maxSeq, err
}

// buildSheet packs glyph images into an RGBA sprite sheet, returning the sheet and a map from sequence string to (x,y).
func buildSheet(glyphs []glyph) (*image.RGBA, map[string][2]int) {
	n := len(glyphs)
	rows := (n + columns - 1) / columns
	sheet := image.NewRGBA(image.Rect(0, 0, columns*cellW, rows*cellH))
	index := make(map[string][2]int, n)
	for i, g := range glyphs {
		f, err := os.Open(g.Path)
		if err != nil {
			panic(err)
		}
		img, err := png.Decode(f)
		f.Close()
		if err != nil {
			panic(err)
		}
		// Destination cell rectangle.
		x := (i % columns) * cellW
		y := (i / columns) * cellH
		cellRect := image.Rect(x, y, x+cellW, y+cellH)
		draw.Draw(sheet, cellRect, image.Transparent, image.Point{}, draw.Src)
		b := img.Bounds()
		// Top-left placement; could center if smaller than cell.
		draw.Draw(sheet, image.Rect(x, y, x+b.Dx(), y+b.Dy()), img, b.Min, draw.Over)
		seqKey := string(g.Runes)
		index[seqKey] = [2]int{x / cellW, y / cellH}
	}
	return sheet, index
}

func writeOutput(pngFileName string, index map[string][2]int, count, maxSeq int) error {
	var b bytes.Buffer
	b.WriteString(headerComment)
	b.WriteString("package emoji\n\n")
	b.WriteString("import (\n\t_ \"embed\"\n\t\"image\"\n)\n\n")
	b.WriteString(fmt.Sprintf("// Packed %d emoji at %dx%d cells, columns=%d\n", count, cellW, cellH, columns))
	b.WriteString(fmt.Sprintf("const CellW = %d\nconst CellH = %d\nconst SheetCols = %d\nconst MaxSequence = %d\n\n", cellW, cellH, columns, maxSeq))

	b.WriteString(fmt.Sprintf("//go:embed %s\n", pngFileName))
	b.WriteString(fmt.Sprintf("var Sprites []byte\n\n"))

	b.WriteString("// Index maps a Unicode sequence (string of runes) to sprite sheet cell coordinates.\n")
	b.WriteString("var Index = map[string]image.Point{\n")
	// For deterministic output, gather keys and sort by length desc then lexicographically by bytes.
	keys := make([]string, 0, len(index))
	for k := range index {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		if len([]rune(keys[i])) != len([]rune(keys[j])) {
			return len([]rune(keys[i])) > len([]rune(keys[j]))
		}
		return keys[i] < keys[j]
	})
	for _, k := range keys {
		xy := index[k]
		// Use %q to properly escape the string literal.
		b.WriteString(fmt.Sprintf("\t%q: {X:%d, Y:%d},\n", k, xy[0], xy[1]))
	}
	b.WriteString("}\n\n")

	return os.WriteFile(outFile, b.Bytes(), 0o644)
}

// findModuleRoot walks up directories until a go.mod is found.
func findModuleRoot(start string) string {
	dir := start
	for i := 0; i < 10; i++ { // safety limit
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Clean(filepath.Join(dir, ".."))
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}
