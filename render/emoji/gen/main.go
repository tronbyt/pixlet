// Emoji sprite sheet generator.
//
// Usage:
//
//	go run ./render/gen/main.go
//
// (Normally invoked via `go generate ./render`.)
//
// Scans assets/emoji/raw for PNG files named like:
//
//	U+1F600.png (single codepoint) OR
//	U+1F1FA_U+1F1F8.png (multi-codepoint sequence)
//
// Packs all images into a sprite sheet sized by each glyph's intrinsic bounds and emits
// `fonts/emoji/sprites.go` containing:
//   - embedded sprite sheet bytes
//   - a map[string]Glyph (keys are the actual Unicode sequence string)
//   - constants for sheet dimensions, glyph extrema, and max sequence length
//
// Multi-codepoint sequences (e.g. flags, keycap sequences) are supported.
// ZWJ (\u200D) sequences are included only if PNG assets are present; no special
// shaping is doneâ€”longest-match logic at runtime handles them.
package main

import (
	"bufio"
	"bytes"
	"cmp"
	"fmt"
	"image"
	"image/draw"
	"image/png"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"unicode/utf8"
)

const (
	sheetWidthLimit = 640 // soft limit for packing rows; final sheet may be narrower
	glyphPadding    = 1   // pixels of transparent padding on each side of a glyph
	headerComment   = "// Code generated by render/emoji/gen; DO NOT EDIT.\n"
)

// Computed at runtime.
var (
	rawDir         string
	variationsFile string
	outFile        string
	pngFile        string
	fallbackFile   string
)

type glyph struct {
	Runes      []rune
	Path       string
	IsFallback bool
}

func main() {
	fontsDir := "fonts"
	emojiDir := filepath.Join(fontsDir, "emoji")
	if err := os.MkdirAll(emojiDir, 0o755); err != nil {
		panic(err)
	}
	rawDir = filepath.Join("assets", "emoji", "raw")
	variationsFile = filepath.Join("assets", "emoji", "emoji-variation-sequences.txt")
	fallbackFile = filepath.Join("assets", "emoji", "fallback.png")
	outFile = filepath.Join(emojiDir, "sprites.go")
	pngFile = filepath.Join(emojiDir, "sprites.png")

	emojiVariations, err := collectEmojiVariations()
	if err != nil {
		panic(err)
	}

	glyphs, maxSeq, err := collect(emojiVariations)
	if err != nil {
		panic(err)
	}
	if len(glyphs) == 0 {
		fmt.Println("No emoji assets found; not writing sheet.")
		return
	}
	if _, err := os.Stat(fallbackFile); err != nil {
		panic(fmt.Errorf("fallback emoji asset missing: %w", err))
	}
	glyphs = append(glyphs, glyph{Path: fallbackFile, IsFallback: true})

	sheet, index, fallbackRect, sheetW, sheetH, maxHeight, maxWidth := buildSheet(glyphs)
	if fallbackRect.Empty() {
		panic("failed to generate fallback glyph, is fallback.png empty?")
	}

	var pngBuf bytes.Buffer
	if err := png.Encode(&pngBuf, sheet); err != nil {
		panic(err)
	}
	if err := os.WriteFile(pngFile, pngBuf.Bytes(), 0o644); err != nil {
		panic(err)
	}

	if err := writeOutput(filepath.Base(pngFile), index, fallbackRect, len(index), maxSeq, sheetW, sheetH, maxHeight, maxWidth); err != nil {
		panic(err)
	}
	fmt.Printf("Generated %s and %s with %d emoji (max sequence len %d). PNG=%d bytes\n", outFile, pngFile, len(index), maxSeq, pngBuf.Len())
}

// collect scans rawDir for U+....png names.
func collect(emojiVariations map[string]struct{}) ([]glyph, int, error) {
	out := []glyph{}
	maxSeq := 1
	err := filepath.WalkDir(rawDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		base := filepath.Base(path)
		if !strings.HasPrefix(base, "U+") || !strings.HasSuffix(strings.ToLower(base), ".png") {
			return nil
		}
		name := strings.TrimSuffix(base, ".png")
		parts := strings.Split(name, "_")
		runes := []rune{}
		for _, p := range parts {
			if !strings.HasPrefix(p, "U+") { // skip malformed
				return nil
			}
			hexPart := strings.TrimPrefix(p, "U+")
			v, err := strconv.ParseInt(hexPart, 16, 32)
			if err != nil {
				return err
			}
			runes = append(runes, rune(v))
		}
		if len(runes) > 0 {
			originalSeq := string(runes)
			if _, ok := emojiVariations[originalSeq]; ok && runes[len(runes)-1] != '\uFE0F' {
				runes = append(runes, '\uFE0F')
			}
		}
		if l := len(runes); l > maxSeq {
			maxSeq = l
		}
		out = append(out, glyph{Runes: runes, Path: path})
		return nil
	})
	// Stable ordering: by sequence length (desc) then lexicographically by runes.
	slices.SortFunc(out, func(a, b glyph) int {
		if c := cmp.Compare(len(b.Runes), len(a.Runes)); c != 0 {
			return c // longer first
		}
		return slices.Compare(a.Runes, b.Runes) // lexicographic on rune slices
	})
	return out, maxSeq, err
}

// buildSheet packs glyph images into a sprite sheet using each glyph's intrinsic width, returning
// the sheet along with glyph metadata (pixel coordinates and dimensions) plus aggregate metrics.
func buildSheet(glyphs []glyph) (*image.NRGBA, map[string]image.Rectangle, image.Rectangle, int, int, int, int) {
	type placement struct {
		glyph      glyph
		img        image.Image
		x, y       int
		w, h       int
		boxW, boxH int
	}

	placements := make([]placement, 0, len(glyphs))
	cursorX, cursorY := 0, 0
	rowHeight, rowWidth := 0, 0
	maxRowWidth, maxHeight, maxGlyphWidth := 0, 0, 0

	for _, g := range glyphs {
		f, err := os.Open(g.Path)
		if err != nil {
			panic(err)
		}
		img, err := png.Decode(f)
		_ = f.Close()
		if err != nil {
			panic(err)
		}

		b := img.Bounds()
		w, h := b.Dx(), b.Dy()
		if w == 0 || h == 0 {
			continue
		}

		totalW := w + glyphPadding*2
		if totalW > maxGlyphWidth {
			maxGlyphWidth = totalW
		}

		boxW := totalW
		boxH := h

		if cursorX != 0 && cursorX+boxW > sheetWidthLimit {
			if rowWidth > maxRowWidth {
				maxRowWidth = rowWidth
			}
			cursorX = 0
			cursorY += rowHeight
			rowHeight = 0
			rowWidth = 0
		}

		placements = append(placements, placement{
			glyph: g,
			img:   img,
			x:     cursorX + glyphPadding,
			y:     cursorY,
			w:     w,
			h:     h,
			boxW:  boxW,
			boxH:  boxH,
		})
		cursorX += boxW
		rowWidth = cursorX
		if rowHeight < h {
			rowHeight = h
		}
		if maxHeight < h {
			maxHeight = h
		}
		if rowWidth > maxRowWidth {
			maxRowWidth = rowWidth
		}
	}

	if len(placements) == 0 {
		return image.NewNRGBA(image.Rect(0, 0, 0, 0)), map[string]image.Rectangle{}, image.Rectangle{}, 0, 0, 0, 0
	}

	if rowWidth > maxRowWidth {
		maxRowWidth = rowWidth
	}

	sheetWidth := maxRowWidth
	if sheetWidth == 0 {
		sheetWidth = sheetWidthLimit
	}
	sheetHeight := cursorY + rowHeight

	sheet := image.NewNRGBA(image.Rect(0, 0, sheetWidth, sheetHeight))
	index := make(map[string]image.Rectangle, len(placements))
	var fallbackRect image.Rectangle

	for _, p := range placements {
		boxRect := image.Rect(p.x-glyphPadding, p.y, p.x-glyphPadding+p.boxW, p.y+p.boxH)
		draw.Draw(sheet, boxRect, image.Transparent, image.Point{}, draw.Src)
		glyphRect := image.Rect(p.x, p.y, p.x+p.w, p.y+p.h)
		draw.Draw(sheet, glyphRect, p.img, p.img.Bounds().Min, draw.Over)
		if p.glyph.IsFallback {
			fallbackRect = boxRect
			continue
		}
		seqKey := string(p.glyph.Runes)
		index[seqKey] = boxRect
	}

	return sheet, index, fallbackRect, sheetWidth, sheetHeight, maxHeight, maxGlyphWidth
}

func collectEmojiVariations() (map[string]struct{}, error) {
	f, err := os.Open(variationsFile)
	if err != nil {
		return nil, fmt.Errorf("open emoji variation sequences: %w", err)
	}
	defer func() {
		_ = f.Close()
	}()

	sequences := make(map[string]struct{})
	scanner := bufio.NewScanner(f)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		parts := strings.Split(line, ";")
		if len(parts) < 2 {
			continue
		}
		if strings.TrimSpace(parts[1]) != "emoji style" {
			continue
		}
		codepoints := strings.Fields(parts[0])
		if len(codepoints) == 0 {
			continue
		}
		if !strings.EqualFold(codepoints[len(codepoints)-1], "FE0F") {
			continue
		}
		runes := make([]rune, 0, len(codepoints)-1)
		valid := true
		for _, cp := range codepoints[:len(codepoints)-1] {
			v, err := strconv.ParseInt(cp, 16, 32)
			if err != nil {
				valid = false
				break
			}
			runes = append(runes, rune(v))
		}
		if valid && len(runes) != 0 {
			sequences[string(runes)] = struct{}{}
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("parse emoji variation sequences: %w", err)
	}
	return sequences, nil
}

func writeOutput(pngFileName string, index map[string]image.Rectangle, fallback image.Rectangle, count, maxSeq, sheetW, sheetH, maxHeight, maxWidth int) error {
	var b bytes.Buffer
	b.WriteString(headerComment)
	b.WriteString("package emoji\n\n")
	b.WriteString("import (\n\t_ \"embed\"\n\t\"image\"\n)\n\n")
	b.WriteString(fmt.Sprintf("// Packed %d emoji with variable-width sprites (max glyph height %d, max glyph width %d), sheet=%dx%d\n", count, maxHeight, maxWidth, sheetW, sheetH))
	b.WriteString(fmt.Sprintf("const SheetWidth = %d\nconst SheetHeight = %d\nconst MaxHeight = %d\nconst MaxWidth = %d\nconst MaxSequence = %d\n\n", sheetW, sheetH, maxHeight, maxWidth, maxSeq))

	b.WriteString(fmt.Sprintf("//go:embed %s\n", pngFileName))
	b.WriteString(fmt.Sprintf("var Sprites []byte\n\n"))

	b.WriteString("// Fallback is the sprite bounds for the default glyph used when an emoji sequence is missing.\n")
	b.WriteString(fmt.Sprintf("var Fallback = image.Rectangle{Min: image.Point{X:%d, Y:%d}, Max: image.Point{X:%d, Y:%d}}\n\n", fallback.Min.X, fallback.Min.Y, fallback.Max.X, fallback.Max.Y))

	b.WriteString("// Index maps a Unicode sequence (string of runes) to glyph bounds within the sprite sheet.\n")
	b.WriteString("var Index = map[string]image.Rectangle{\n")
	// For deterministic output, gather keys and sort by length desc then lexicographically by bytes.
	keys := make([]string, 0, len(index))
	for k := range index {
		keys = append(keys, k)
	}
	slices.SortFunc(keys, func(a, b string) int {
		if c := cmp.Compare(utf8.RuneCountInString(b), utf8.RuneCountInString(a)); c != 0 {
			return c // longer first
		}
		return cmp.Compare(a, b) // lexicographic
	})
	for _, k := range keys {
		xy := index[k]
		b.WriteString(fmt.Sprintf("\t%q: image.Rectangle{Min: image.Point{X:%d, Y:%d}, Max: image.Point{X:%d, Y:%d}},\n", k, xy.Min.X, xy.Min.Y, xy.Max.X, xy.Max.Y))
	}
	b.WriteString("}\n\n")

	return os.WriteFile(outFile, b.Bytes(), 0o644)
}
